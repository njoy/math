#ifndef MATH_IMPLEMENTATION_BIVARIATEPROBABILITYDISTRIBUTION_SRC_GIVENCONDITION_HPP
#define MATH_IMPLEMENTATION_BIVARIATEPROBABILITYDISTRIBUTION_SRC_GIVENCONDITION_HPP

#include <memory>

#include "math/implementation/SplicedProbabilityDistribution.hpp"

namespace math{
namespace implementation{

/** @brief The conditional probability density or \f$P(x | y)\f$
 *
 * @returns the probability of @p event given the @p condition
 *
 * @details It is the responsibility of the whoever calls this method to verify
 * that the event is valid.
 *
 */
template< double pdfInterp( const double x,
                            const double x1, const double x2,
                            const double y1, const double y2 ),
          double cdfInterp( const double x,
                            const double x1, const double x2,
                            const double y1, const double y2 ) >
std::unique_ptr< math::API::ProbabilityDistribution >
BivariateProbabilityDistribution
< pdfInterp, cdfInterp >::givenCondition( const double condition ) const {

  const auto conditionIter = std::lower_bound( this->conditions.begin(),
                                               this->conditions.end(),
                                               condition );
  try{
    if( conditionIter == this->conditions.end() ){
      LOG(ERROR) <<
        "Queried condition value is outside the bounds of the distribution";
      LOG(INFO) << "Condition value: " << condition;
      LOG(INFO) << "Upper boundary of distribution: " 
                << this->conditions.back();
      throw std::exception();
    }

    if( condition < this->conditions.front() ){
      LOG(ERROR) <<
        "Queried condition value is outside the bounds of the distribution";
      LOG(INFO) << "Condition value: " << condition;
      LOG(INFO) << "Lower boundary of distribution: " 
                << this->conditions.front();
      throw std::exception();
    }

    const auto conditionIterDistance = conditionIter - this->conditions.begin();
    const auto& distributionIter =
      this->conditionedProbabilityDistributions.begin() + conditionIterDistance;
    const auto& rightDistribution = *(distributionIter[0]);

    if( conditionIter == this->conditions.begin() ){
      std::array<double, 2> conditions =
        {{ conditionIter[0], 0.0 }};
      
      return
        std::make_unique
        < math::implementation::SplicedProbabilityDistribution
          < pdfInterp, cdfInterp> >
        ( condition, &rightDistribution, nullptr, conditions );
    }

    const auto& leftDistribution = *(distributionIter[-1]); 

    std::array<double, 2> conditions =
        {{ conditionIter[-1], conditionIter[0] }};
    
    return
      std::make_unique
      < math::implementation::SplicedProbabilityDistribution
        < pdfInterp, cdfInterp > >
      ( condition, &leftDistribution, &rightDistribution, conditions );


  } catch (std::exception& e){
    LOG(INFO) << "Error while generating probability distribution "
              << "in BivariateProbabilityDistribution givenCondition method.";
    throw e;
  }
}

} // namespace implementation
} // namespace math

#endif //  MATH_IMPLEMENTATION_BIVARIATEPROBABILITYDISTRIBUTION_SRC_CONDITIONALPROBABILITYDENSITY_HPP
