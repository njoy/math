#ifndef MATH_IMPLEMENTATION_VECTORINTERPOLATIONREGION_HPP
#define MATH_IMPLEMENTATION_VECTORINTERPOLATIONREGION_HPP

#include "math/API/InterpolationRegion.hpp"
#include "math/implementation.hpp"

namespace math{
namespace implementation{

template<double interpolation(const double x,
                              const double x1, const double x2,
                              const double y1, const double y2) >
class VectorInterpolationRegion : public math::API::InterpolationRegion {
public:
  /* convenience typedef */
  typedef math::implementation::InterpolationRegionIntegral
  < std::vector<double>::iterator, interpolation >
  InterpolationRegionIntegral;
  
  /* fields */
  mutable std::vector<double> x;
  mutable std::vector<double> y;
  math::implementation::IteratorInterpolationRegion
  < std::vector<double>::iterator, interpolation > iir; 
  /* Why the mutable keyword? */
  /* The mutable keyword was the least heinous work around for coping with
   * difficulties associated with specify the iir fields type. The trouble 
   * stems from the fact that the std::vector class template uses a const
   * overload for the 'begin' and 'end' methods, return a instance of the 
   * vector<T>::iterator type when mutable and vector<T>::const_iterator when
   * immutable. Because these classes are not interoperable, it becomes 
   * difficult to specify the iir field's iterator type parameter. By declaring
   * the vector fields as mutable, their return type will be vectr<T>::iterator,
   * regardless of whether the VectorInterpolationRegion instace is const or
   * mutable
   */ 

  /* constructor and desctructor */
  VectorInterpolationRegion(
    std::vector<double>&& x,
    std::vector<double>&& y,
    const bool trust = true) :
    x(std::move(x)),
    y(std::move(y)),
    iir( math::implementation::IteratorInterpolationRegion
         < std::vector<double>::iterator, interpolation >
         ( this->x.begin(), this->x.end(),
           this->y.begin(), this->y.end(), trust )){}
  
  VectorInterpolationRegion( VectorInterpolationRegion&& ) = default;
  
  ~VectorInterpolationRegion() = default;
  
  /* methods */
  double
  xMin() const final { return this->iir.xMin(); }
  
  double
  xMax() const final { return this->iir.xMax(); }

  std::vector< utility::View<double> >
  xGrid() final { return this->iir.xGrid(); }
  
  std::vector< utility::View<const double> >
  xGrid() const final { return this->iir.xGrid(); }

  std::vector< utility::View<double> >
  yGrid() final { return this->iir.yGrid(); }

  std::vector< utility::View<const double> >
  yGrid() const final { return this->iir.yGrid(); }

  std::unique_ptr< math::API::InterpolationRegionIntegral >
  integral(const double y0) const /* final */ {
    return this->iir.integral(y0);
  }
  
  InterpolationRegionIntegral
  specifiedIntegral(const double y0) const {
    return this->iir.specifiedIntegral(y0);
  }
  
  double
  interpolate(const double x) const final { return this->iir.interpolate(x); }
};

} // namespace implementation
} // namespace math

#endif
