#include "math/implementation/IteratorInterpolationRegion.hpp"

namespace math{
namespace implementation{

template<typename randomAccessIter,
         double interpolation(const double x,
                              const double x1, const double x2,
                              const double y1, const double y2) >
inline
IteratorInterpolationRegion<randomAccessIter,
                            interpolation>::IteratorInterpolationRegion(
  randomAccessIter xBegin,
  randomAccessIter xEnd,
  randomAccessIter yBegin,
  randomAccessIter yEnd,
  const bool trust) : xBegin(std::move(xBegin)),
                      xEnd(std::move(xEnd)),
                      yBegin(std::move(yBegin)){
  static_assert(
    std::is_same<
    typename std::iterator_traits<randomAccessIter>::value_type,
    double >::value,
    "Iterpolation is only defined for double precision" );

  /* Why require random access iterator? */
  /* Binary search is used to locate the appropriate neighboring points
   * along the interpolation grid. To do this efficiently, random access
   * is necessary. I chose to require the means to operate efficiently
   * rather than allow an end-user to mistakenly instatiate this class for 
   * an iterator type that would function properly but perform poorly.
   */
  static_assert(
    std::is_same<
    typename std::iterator_traits<randomAccessIter>::iterator_category,
    std::random_access_iterator_tag >::value,
    "Iteration only defined for random access iterators" );
  
  if (!trust){
    if (this->xBegin - this->xEnd != this->yBegin - yEnd){
      LOG(ERROR) << "The independent and dependent variable interpolation grids "
        "do not contain the same number of elements";
      LOG(INFO) << "X-grid size: " << this->xEnd - this->xBegin;
      LOG(INFO) << "Y-grid size: " << yEnd - this->yBegin;      
      throw std::exception();
    }
    auto it = std::is_sorted_until(this->xBegin, this->xEnd);
    if ( it != this->xEnd){
      LOG(ERROR) << "Independent variable is not ordered.";
      LOG(INFO) <<
        "Each value in the X-grid must less than or equal to its successor";
      LOG(INFO) << "Element " << it - this->xBegin - 1 << ": " << it[-1];
      LOG(INFO) << "Element " << it - this->xBegin << ": " << it[0];
      throw std::exception();
    }
  }
}

} // namespace implementation 
} // namespace math
